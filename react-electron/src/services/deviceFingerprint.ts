/**
 * Device Fingerprinting Service
 * TypeScript service for collecting unique device characteristics
 */

import { DeviceFingerprint, DeviceData } from "../types";

/**
 * Collect comprehensive device information for fingerprinting
 */
export async function collectDeviceInfo(): Promise<DeviceData> {
  try {
    console.log("üîç Collecting device information...");

    // Get real system info from Electron main process (Node.js)
    let realSystemInfo: any = null;
    if (window.electronAPI?.getSystemInfo) {
      try {
        realSystemInfo = await window.electronAPI.getSystemInfo();
        console.log("üíª Got real system info from Electron:", realSystemInfo);
      } catch (error) {
        console.warn("‚ö†Ô∏è Could not get system info from Electron:", error);
      }
    }

    // Use real CPU info if available, otherwise fallback to browser data
    const cpuModel = realSystemInfo?.cpu?.model || `CPU-${navigator.hardwareConcurrency || 0}cores`;
    const cpuCores = realSystemInfo?.cpu?.cores || navigator.hardwareConcurrency || 0;
    const cpuArch = realSystemInfo?.cpu?.architecture || (navigator as any).userAgentData?.platform || "unknown";

    const fingerprint: DeviceFingerprint = {
      cpu: {
        cores: cpuCores,
        architecture: cpuArch,
        model: cpuModel, // Real CPU model from Node.js os module
      },
      gpu: {
        renderer: "unknown",
        vendor: "unknown",
        memory: 0,
      },
      system: {
        platform: (navigator as any).userAgentData?.platform || "unknown",
        version: navigator.userAgent || "unknown",
        architecture: (navigator as any).userAgentData?.platform || "unknown",
        language: navigator.language || "en-US",
      },
      network: {
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC",
        timezoneOffset: new Date().getTimezoneOffset(),
      },
      browser: {
        userAgent: navigator.userAgent,
        languages: Array.from(navigator.languages || [navigator.language]),
      },
    };

    // Try to get WebGL info
    try {
      const canvas = document.createElement("canvas");
      const gl =
        canvas.getContext("webgl") ||
        (canvas.getContext(
          "experimental-webgl"
        ) as WebGLRenderingContext | null);

      if (gl) {
        const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
        if (debugInfo) {
          fingerprint.gpu.renderer =
            gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) || "unknown";
          fingerprint.gpu.vendor =
            gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) || "unknown";
        }

        // Try to get WebGL fingerprint
        const webglFingerprint = getWebGLFingerprint(gl);
        fingerprint.browser.webgl = webglFingerprint;
      }
    } catch (e) {
      console.warn("‚ö†Ô∏è Could not get WebGL info:", e);
    }

    // Try to get Canvas fingerprint
    try {
      fingerprint.browser.canvas = getCanvasFingerprint();
    } catch (e) {
      console.warn("‚ö†Ô∏è Could not get Canvas fingerprint:", e);
    }
    

    const deviceData: DeviceData = {
      fingerprint,
      hash: "", // Will be generated by backend
      timestamp: Date.now(),
    };

    console.log("‚úÖ Device information collected successfully");
    console.log(
      `üì± Device: ${fingerprint.system.platform} ${fingerprint.system.architecture}`
    );
    console.log(`üíæ CPU Cores: ${fingerprint.cpu.cores}`);

    return deviceData;
  } catch (error) {
    console.error("‚ùå Failed to collect device info:", error);
    throw error;
  }
}

/**
 * Generate WebGL fingerprint
 */
function getWebGLFingerprint(gl: WebGLRenderingContext): string {
  try {
    const canvas = gl.canvas as HTMLCanvasElement;
    const vertexShaderSource = `
      attribute vec2 position;
      void main() {
        gl_Position = vec4(position, 0.0, 1.0);
      }
    `;

    const fragmentShaderSource = `
      precision mediump float;
      void main() {
        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
      }
    `;

    const program = createShaderProgram(
      gl,
      vertexShaderSource,
      fragmentShaderSource
    );
    if (!program) return "webgl-error";

    // Create a simple triangle
    const vertices = new Float32Array([-0.5, -0.5, 0.5, -0.5, 0.0, 0.5]);

    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    const positionLocation = gl.getAttribLocation(program, "position");
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    gl.useProgram(program);
    gl.drawArrays(gl.TRIANGLES, 0, 3);

    return canvas.toDataURL().slice(0, 100); // Take first 100 chars
  } catch (e) {
    return "webgl-fingerprint-error";
  }
}

/**
 * Create WebGL shader program
 */
function createShaderProgram(
  gl: WebGLRenderingContext,
  vertexSource: string,
  fragmentSource: string
): WebGLProgram | null {
  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);

  if (!vertexShader || !fragmentShader) return null;

  const program = gl.createProgram();
  if (!program) return null;

  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);

  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    gl.deleteProgram(program);
    return null;
  }

  return program;
}

/**
 * Create WebGL shader
 */
function createShader(
  gl: WebGLRenderingContext,
  type: number,
  source: string
): WebGLShader | null {
  const shader = gl.createShader(type);
  if (!shader) return null;

  gl.shaderSource(shader, source);
  gl.compileShader(shader);

  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    gl.deleteShader(shader);
    return null;
  }

  return shader;
}

/**
 * Generate Canvas fingerprint
 */
function getCanvasFingerprint(): string {
  try {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    if (!ctx) return "canvas-error";

    canvas.width = 200;
    canvas.height = 50;

    // Draw text with different properties
    ctx.textBaseline = "top";
    ctx.font = "14px Arial";
    ctx.fillStyle = "#f60";
    ctx.fillRect(125, 1, 62, 20);
    ctx.fillStyle = "#069";
    ctx.fillText("Hello, world! üåç", 2, 15);
    ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
    ctx.fillText("Hello, world! üåç", 4, 17);

    // Draw some shapes
    ctx.globalCompositeOperation = "multiply";
    ctx.fillStyle = "rgb(255,0,255)";
    ctx.beginPath();
    ctx.arc(50, 50, 50, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "rgb(0,255,255)";
    ctx.beginPath();
    ctx.arc(100, 50, 50, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.fill();

    return canvas.toDataURL().slice(0, 100); // Take first 100 chars
  } catch (e) {
    return "canvas-fingerprint-error";
  }
}


/**
 * Generate a simple hash from device data (for client-side use only)
 * Note: Real hashing should be done on the server for security
 */
export function generateSimpleHash(data: DeviceData): string {
  const str = JSON.stringify(data.fingerprint);
  let hash = 0;

  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash; // Convert to 32-bit integer
  }

  return Math.abs(hash).toString(16);
}

/**
 * Validate device data structure
 */
export function validateDeviceData(data: any): data is DeviceData {
  return (
    data &&
    typeof data === "object" &&
    data.fingerprint &&
    typeof data.fingerprint === "object" &&
    data.fingerprint.cpu &&
    data.fingerprint.gpu &&
    data.fingerprint.system &&
    data.fingerprint.network &&
    data.fingerprint.browser &&
    typeof data.timestamp === "number"
  );
}
